通过 引用计数 进行垃圾回收
typedef struct_object {
    int ob_refcnt;  // 引用计数器
    struct_typeobject *ob_type;
} PyObject;  // 核心结构体

当对象的引用计数值为0，则其内存立即被释放

一般引用计数增加：
对象被创建
对象被引用
对象被作为参数，传入到一个函数中
对象作为一个元素，存储在容器中

一般引用计数减少：
对象别名被显示销毁 del
对象别名被赋予新的对象
一个对象离开他的作用域

缺点：
可能较慢：比如注销一个大的字典对象，需要对字典中所有的对象循环嵌套调用，从而可能花的时间长一点。
循环引用：致命点。只有容器对象才会产生循环引用的情况，比如列表、字典、用户自定义类的对象、元组等。


一、标记-清除（Mark and Sweep） 解决循环引用
在进行垃圾回收的时候分为两步：
A：标记阶段 》》遍历所有的对象。如果对象是可达的，也就是还有对象引用它，就标记该对象为可达。
B：清除阶段 》》再次遍历对象。弱某对象没有标记为可达，将其回收。

在标记清除算法中，为了追踪容器对象，
需要每个容器对象维护两个额外的指针，用来将容器对象组成一个双端链表，指针分别指向前后两个容器对象，方便插入和删除操作。
Cpython维护了两个这样的双端链表，一个链表存放着需要被扫描的容器对象，另一个链表存放着临时不可达对象


二、分代回收（Generational Collection） 提高效率（基于一定的统计学）
分代回收是基于这样的一个统计事实。
对于程序，存在一定比例的内存块的生存周期比较短；
而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束；
生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：
【对象存在时间越长，越可能不是垃圾，应该越少去收集】
这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。

python gc给对象定义了三种世代(0,1,2),
每一个新生对象在generation zero中。如果它在一轮gc扫描中活了下来，那么它将被移至generation one。
在那里他将较少的被扫描，如果它又活过了一轮gc,它又将被移至generation two，在那里它被扫描的次数将会更少。

gc的扫描在什么时候会被触发呢?
答案是当某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。
值得注意的是当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。
也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。

该阈值可以通过下面两个函数查看和调整:
gc.get_threshold()  # (threshold0, threshold1, threshold2)  # 默认是(700,10,10).
gc.set_threshold(threshold0[, threshold1[, threshold2]])

gc会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过threshold0的值时
gc的扫描就会启动，初始的时候只有世代0被检查
如果自从世代1最近一次被检查以来，世代0被检查超过threshold1次，那么对世代1的检查将被触发
相同的，如果自从世代2最近一次被检查以来，世代1被检查超过threshold2次，那么对世代2的检查将被触发


总体来说，在Python中:
主要通过引用计数进行垃圾回收；
通过 “标记-清除” 解决容器对象可能产生的循环引用问题；
通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。