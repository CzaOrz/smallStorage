前提：
解释器赋值：
a = 'ABC': 解释器做了两件事
1、在内存中创建了一个'ABC'的字符串
2、在内存中创建了一个 a 的变量，并把它指向了 'ABC'
把一个变量a的值赋值给另一个变量b，实际就是把变量b指向了变量a的值

可散列类型：
在可散列对象的生命周期中，他的散列值是不变的。需要实现__hash__和__eq__两个方法
若两个可散列对象是相同的，则散列值一定是一样的
eg:
    string 是可散列对象. '123' is '123' => True

稀疏数组：
所谓稀疏数组就是数组中大部分的内容都未被使用，或者都是零。
数组中仅有少部分空间使用，因此会造成一定的空间浪费。

字典是一个散列表，而散列表其实是一个稀疏数组。散列表的里的每一个单元，我们称之为表元。
也就是说在dict的散列表中，每一个键值对都占据一个表元。
那么我们也就知道每个表元其实分为两部分，一个是对键的引用，一个是对值的引用。
表元大小一样，故可以通过偏移量来读取每一个表元。

计算方式：
    计算键的散列值 -> 使用散列值中的一部分来定位散列表中的一个表元 ->  表元为空 -> 抛出异常KeyError
                                                             |_> 键不相等 -> 散列冲突 -> 取散列值另一部分来定位 -> 循环
                                                             |_> 返回表元中的值

由于这种特性，导致字典：
1、键：必须为可散列，是为了能够唯一定位。
2、在内容上开销巨大：
3、散列冲突会导致字典内无序
