res = re.findall('(工作分工|个人简历)：(.*?)(?=工作分工|个人简历|$)', text, flags=re.S)
content = re.findall('(发布日期|作者|来源).(.*?)(?=作者|来源|阅读)', content)
以上为经典实例

match：从起始位置开始查找，一次匹配
search：从任何位置开始查找，一次匹配
findall：全部匹配，返回列表
finditer：全部匹配，返回迭代器
split：分割字符串，返回列表
sub：替换

re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
re.search(r'^\d{3}\-\d{3,8}$', '010-12345')
re.findall(r'^\d{3}\-\d{3,8}$', '010-12345')
re.finditer(r'^\d{3}\-\d{3,8}$', '010-12345')
re.split(r'[\s]',a,1) #只分割一次
re.sub("\d+", "222", inputStr)

()为了提取匹配字符串，(.*)
[]定义匹配的字符范围，[a-zA-Z0-9]   --- 只能取这里面的一个
{}定义匹配的长度，{0-9}

(0-9)匹配'0-9'本身
[0-9]*匹配数字，若在里面加入了^表示取非，如([^\d].*)
[0-9]{0,9}表示长度为0-9的数字字符串

*可以表示为{0,}
+可以表示为{1,}
?可以表示为{0,1}

在正则中，你要匹配多种，需要使用到[]，比如：([\s\S]*)，你这样才能匹配带任何数据
而这句话，我们可以加入 flags=re.S 表示 . 可以去到任何数据

而且 [匹配-—] 只能匹配到这里面的某一个字，无法具体匹配其字串
此时我们可以使用 (?:匹配|-|—)这样就可以了

(?<=(href=)) 表示匹配以(href=)开发的字符串，并且存储到分组中
(?=(href=)) 表示匹配以(href=)结尾的字符串，并且存储到分组中
(?<=(?:href=)) 表示匹配以(href=)开发的字符串，但不存储到分组中
(?=(?:href=)) 表示匹配以(href=)结尾的字符串，但不存储到分组中

(?:)  (czaissg|czaisorz) 就是 (czais(?:sg|orz))
可以简化表达式

(?=) (czaissg(?=1|2)) 可以匹配'czaissg1' / 'czaissg2'，但不能匹配'czaissg3'
匹配结尾的意思

(?<=) ((?<=1|2)czaissg) 可以匹配'1czaissg' / '2czaissg'，但不能匹配'3czaissg'
匹配开头的意思

(?!) (czaissg(?!1|2))，对于众多的'czaissgx'，不匹配以1,2结尾的，其他都匹配
不匹配结尾字段的意思

(?<!) ((?!1|2)czaissg) 对于众多的'xczaissg'，不匹配以1,2开头的，其他都匹配
U币匹配开头字段的意思

其他说法：
(?:exp) 匹配exp,不捕获匹配的文本
(?=exp) 匹配exp前面的位置
(?<=exp) 匹配exp后面的位置
(?!exp) 匹配后面跟的不是exp的位置
(?<!exp) 匹配前面不是exp的位置

零宽断言，中间隔
re.compile("var\s+(rand\d+)\s*=\"(.+?)\";(?=[\s\S]+document\.write\(\"(.+?)：.+\"\+\\1\+)")